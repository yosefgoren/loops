import struct
from dataclasses import dataclass
import click
from serial import *

# Define the Timestamp dataclass
@dataclass
class Timestamp:
    time: float  # Time in seconds
    id: int      # User-provided ID

def parse_times(filename: str) -> list[Timestamp]:
    """
    Parse the binary log file and return a list of Timestamp objects.

    :param filename: Path to the binary log file.
    :return: List of Timestamp objects.
    """
    timestamps = []

    # Structure format: 'di' corresponds to double (time) and int (ID)
    struct_format = "dQ"
    entry_size = struct.calcsize(struct_format)

    with open(filename, "rb") as f:
        while True:
            # Read a single log entry
            entry_data = f.read(entry_size)
            if not entry_data:
                break  # EOF

            # Unpack the binary data into a tuple
            time, id = struct.unpack(struct_format, entry_data)

            # Create a Timestamp object and append to the list
            timestamps.append(Timestamp(time=time, id=id))
    return timestamps

@click.command()
@click.option('-o', '--output', required=True, type=str, help="A json file with all generated loop performance samples")
@click.option('-t', '--runtimes_file', required=True, type=str, help="A file with raw runtime logs generated by a timed program")
@click.option('-s', '--source_file', required=True, type=str, help="A file with the source code being analyzed")
@click.option('-l', '--loops_file', required=True, type=str, help="A json file with information on all targeted loops in code")
def collect(output: str, runtimes_file: str, source_file: str, loops_file: str):
    parsed_timestamps: list[Timestamp] = parse_times(runtimes_file)
    times_dict = {stamp.id: stamp.time for stamp in parsed_timestamps}
    
    targets: list[ForLoop] = load_targets_file(loops_file)
    assert len(targets) > 0
    assert source_file == targets[0].for_token.file
    full_src_code: str = open(source_file, 'r').read()
    samples: list[LoopSample] = []
    
    for tgt in targets:
        start_time: float = times_dict[tgt.ident*2]
        end_time: float = times_dict[tgt.ident*2 + 1]
        duration: float = end_time - start_time
        samples.append(LoopSample(
            tgt,
            full_src_code[tgt.for_token.offset:tgt.scope.end_pos.offset],
            duration,
        ))
    
    dump_samples_file(output, samples)

if __name__ == "__main__":
    collect()