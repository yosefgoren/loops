import struct
from dataclasses import dataclass
import click
from utils.serialize import *

# Define the Timestamp dataclass
@dataclass
class Timestamp:
    time: float  # Time in seconds
    id: int      # User-provided ID
    thread_id: int # Thread ID of logging thread

def parse_times(filename: str) -> list[Timestamp]:
    """
    Parse the binary log file and return a list of Timestamp objects.

    :param filename: Path to the binary log file.
    :return: List of Timestamp objects.
    """
    timestamps = []

    # Structure format: 'di' corresponds to double (time) and int (ID)
    struct_format = "dQi"
    entry_size = struct.calcsize(struct_format)

    with open(filename, "rb") as f:
        while True:
            # Read a single log entry
            entry_data = f.read(entry_size)
            if not entry_data:
                break  # EOF

            # Unpack the binary data into a tuple
            time, id, thread_id = struct.unpack(struct_format, entry_data)

            # Create a Timestamp object and append to the list
            timestamps.append(Timestamp(time=time, id=id, thread_id=thread_id))
    return timestamps

@click.command()
@click.option('-o', '--output', required=True, type=str, help="A json file with all generated loop performance samples")
@click.option('-t', '--runtimes_file', required=True, type=str, help="A file with raw runtime logs generated by a timed program")
@click.option('-s', '--source_file', required=True, type=str, help="A file with the source code being analyzed")
@click.option('-l', '--loops_file', required=True, type=str, help="A json file with information on all targeted loops in code")
def collect(output: str, runtimes_file: str, source_file: str, loops_file: str):
    parsed_timestamps: list[Timestamp] = parse_times(runtimes_file)
    times_dict: dict[int, dict[int, float]] = {} # For each stamp id, a dict of times per thread.
    for stamp in parsed_timestamps:
        if stamp.id not in times_dict:
            times_dict[stamp.id] = {}
        times_dict[stamp.id][stamp.thread_id] = stamp.time
    
    targets: list[ForLoop] = load_targets_file(loops_file)
    assert len(targets) > 0
    full_src_code: str = open(source_file, 'r').read()
    samples: list[LoopSample] = []
    
    for tgt in targets:
        start_times: dict[int, float] | None = times_dict.get(tgt.ident*2, None)
        end_times: dict[int, float] | None = times_dict.get(tgt.ident*2 + 1, None)
        duration = None
        all_durations: list[float] = []
        if end_times is not None and start_times is not None:
            for thread_id, time_start in start_times.items():
                if thread_id in end_times:
                    all_durations.append(end_times[thread_id] - time_start)
            duration = sum(all_durations)/len(all_durations)

        samples.append(LoopSample(
            tgt,
            full_src_code[tgt.for_token.offset:tgt.scope.end_pos.offset+1],
            duration,
            len(all_durations)
        ))
    
    dump_samples_file(output, samples)

if __name__ == "__main__":
    collect()